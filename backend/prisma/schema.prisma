// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  STUDENT
  TEACHER
  ADMIN
}

enum QuestionType {
  MULTIPLE_CHOICE
  OPEN_ENDED
  READING_COMPREHENSION
}

enum ExamStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ExamAttemptStatus {
  IN_PROGRESS
  COMPLETED
  TIMED_OUT
}

model User {
  id                String    @id @default(cuid())
  email             String    @unique
  phone             String?   @unique
  password          String
  firstName         String
  lastName          String
  role              UserRole  @default(STUDENT)
  balance           Float     @default(0) // Balans - yalnız şagirdlər üçün
  resetToken        String?   // Şifrə bərpası üçün verifikasiya kodu
  resetTokenExpires DateTime? // Şifrə bərpası kodunun müddəti
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  examsCreated     Exam[]            @relation("TeacherExams")
  examAttempts     ExamAttempt[]
  payments         Payment[]
  questionBanks    QuestionBank[]
  followedTeachers TeacherStudent[]  @relation("StudentFollows")
  students         TeacherStudent[]  @relation("TeacherHasStudents")

  @@map("users")
}

model Exam {
  id          String      @id @default(cuid())
  title       String
  description String?
  subject     String
  level       String
  status      ExamStatus  @default(DRAFT)
  duration    Int         // minutes (price will be calculated from this)
  version     Int         @default(1)
  teacherId   String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  publishedAt DateTime?

  teacher      User          @relation("TeacherExams", fields: [teacherId], references: [id])
  topics       ExamTopic[]
  questions    Question[]
  attempts     ExamAttempt[]
  payments     Payment[]
  readingTexts ReadingText[]

  @@map("exams")
}

model TeacherStudent {
  id        String   @id @default(cuid())
  teacherId String
  studentId String
  createdAt DateTime @default(now())

  teacher User @relation("TeacherHasStudents", fields: [teacherId], references: [id], onDelete: Cascade)
  student User @relation("StudentFollows", fields: [studentId], references: [id], onDelete: Cascade)

  @@unique([teacherId, studentId])
  @@map("teacher_students")
}

model ExamTopic {
  id        String   @id @default(cuid())
  examId    String
  name      String
  subject   String   // Fənn adı (məs: Riyaziyyat, Azərbaycan dili)
  order     Int
  points    Float    @default(1) // Default points per question in this topic
  createdAt DateTime @default(now())

  exam       Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)
  questions  Question[]

  @@unique([examId, order])
  @@map("exam_topics")
}

model ReadingText {
  id        String   @id @default(cuid())
  examId    String
  content   String   @db.Text
  order     Int
  createdAt DateTime @default(now())

  exam Exam @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@unique([examId, order])
  @@map("reading_texts")
}

model Question {
  id          String       @id @default(cuid())
  examId      String
  topicId     String?
  type        QuestionType
  content     String       @db.Text
  order       Int
  points      Int          @default(1)
  correctAnswer String?    // For multiple choice: option ID, for open-ended: model answer
  modelAnswer String?      @db.Text // For open-ended questions
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  exam       Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)
  topic      ExamTopic?   @relation(fields: [topicId], references: [id], onDelete: SetNull)
  options    Option[]
  answers    Answer[]

  @@unique([examId, order])
  @@map("questions")
}

model Option {
  id         String   @id @default(cuid())
  questionId String
  content    String   @db.Text
  order      Int
  createdAt  DateTime @default(now())

  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answers  Answer[]

  @@map("options")
}

model QuestionBank {
  id        String       @id @default(cuid())
  teacherId String
  name      String
  subject   String
  level     String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  teacher   User       @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  questions QuestionBankItem[]

  @@map("question_banks")
}

model QuestionBankItem {
  id          String       @id @default(cuid())
  bankId      String
  type        QuestionType
  content     String       @db.Text
  correctAnswer String?
  modelAnswer String?      @db.Text
  createdAt   DateTime     @default(now())

  bank    QuestionBank @relation(fields: [bankId], references: [id], onDelete: Cascade)
  options QuestionBankOption[]

  @@map("question_bank_items")
}

model QuestionBankOption {
  id         String   @id @default(cuid())
  itemId     String
  content    String   @db.Text
  order      Int
  createdAt  DateTime @default(now())

  item QuestionBankItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@map("question_bank_options")
}

model ExamAttempt {
  id         String            @id @default(cuid())
  examId     String
  studentId  String
  status     ExamAttemptStatus @default(IN_PROGRESS)
  score      Float?
  totalScore Float?
  startedAt  DateTime          @default(now())
  submittedAt DateTime?
  expiresAt  DateTime          // Exam end time

  exam    Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  student User    @relation(fields: [studentId], references: [id], onDelete: Cascade)
  answers Answer[]
  payment Payment?

  @@unique([examId, studentId])
  @@map("exam_attempts")
}

model Answer {
  id         String   @id @default(cuid())
  attemptId  String
  questionId String
  optionId   String?  // For multiple choice
  content    String?  @db.Text // For open-ended
  isCorrect  Boolean?
  points     Float?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  attempt ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  option   Option?    @relation(fields: [optionId], references: [id], onDelete: SetNull)

  @@unique([attemptId, questionId])
  @@map("answers")
}

model Payment {
  id            String        @id @default(cuid())
  studentId     String
  examId        String
  attemptId     String?       @unique
  amount        Float
  status        PaymentStatus @default(PENDING)
  transactionId String?       @unique
  stripePaymentId String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  student User      @relation(fields: [studentId], references: [id], onDelete: Cascade)
  exam    Exam      @relation(fields: [examId], references: [id], onDelete: Cascade)
  attempt ExamAttempt? @relation(fields: [attemptId], references: [id], onDelete: SetNull)

  @@map("payments")
}

