generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                String           @id @default(cuid())
  email             String           @unique
  phone             String?          @unique
  password          String
  firstName         String
  lastName          String
  role              UserRole         @default(STUDENT)
  balance           Float            @default(0)
  resetToken        String?
  resetTokenExpires DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  adminBalance      Float            @default(0)
  teacherBalance    Float            @default(0)
  stripeAccountId   String?
  examAttempts      ExamAttempt[]
  examsCreated      Exam[]           @relation("TeacherExams")
  payments          Payment[]
  questionBanks     QuestionBank[]
  followedTeachers  TeacherStudent[] @relation("StudentFollows")
  students          TeacherStudent[] @relation("TeacherHasStudents")
  withdrawals       Withdrawal[]

  @@map("users")
}

model Exam {
  id           String        @id @default(cuid())
  title        String
  description  String?
  subject      String
  level        String
  status       ExamStatus    @default(DRAFT)
  duration     Int
  version      Int           @default(1)
  teacherId    String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  publishedAt  DateTime?
  attempts     ExamAttempt[]
  topics       ExamTopic[]
  teacher      User          @relation("TeacherExams", fields: [teacherId], references: [id])
  payments     Payment[]
  questions    Question[]
  readingTexts ReadingText[]

  @@map("exams")
}

model TeacherStudent {
  id        String   @id @default(cuid())
  teacherId String
  studentId String
  createdAt DateTime @default(now())
  student   User     @relation("StudentFollows", fields: [studentId], references: [id], onDelete: Cascade)
  teacher   User     @relation("TeacherHasStudents", fields: [teacherId], references: [id], onDelete: Cascade)

  @@unique([teacherId, studentId])
  @@map("teacher_students")
}

model ExamTopic {
  id        String     @id @default(cuid())
  examId    String
  name      String
  subject   String
  order     Int
  points    Float      @default(1)
  createdAt DateTime   @default(now())
  exam      Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)
  questions Question[]

  @@unique([examId, order])
  @@map("exam_topics")
}

model ReadingText {
  id        String     @id @default(cuid())
  examId    String
  content   String
  order     Int
  createdAt DateTime   @default(now())
  questions Question[]
  exam      Exam       @relation(fields: [examId], references: [id], onDelete: Cascade)

  @@unique([examId, order])
  @@map("reading_texts")
}

model Question {
  id            String       @id @default(cuid())
  examId        String
  topicId       String?
  readingTextId String?
  type          QuestionType
  content       String
  order         Int
  points        Int          @default(1)
  correctAnswer String?
  modelAnswer   String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  answers       Answer[]
  options       Option[]
  exam          Exam         @relation(fields: [examId], references: [id], onDelete: Cascade)
  readingText   ReadingText? @relation(fields: [readingTextId], references: [id])
  topic         ExamTopic?   @relation(fields: [topicId], references: [id])

  @@unique([examId, order])
  @@map("questions")
}

model Option {
  id         String   @id @default(cuid())
  questionId String
  content    String
  order      Int
  createdAt  DateTime @default(now())
  answers    Answer[]
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("options")
}

model QuestionBank {
  id        String             @id @default(cuid())
  teacherId String
  name      String
  subject   String
  level     String?
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  questions QuestionBankItem[]
  teacher   User               @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@map("question_banks")
}

model QuestionBankItem {
  id            String               @id @default(cuid())
  bankId        String
  type          QuestionType
  content       String
  correctAnswer String?
  modelAnswer   String?
  createdAt     DateTime             @default(now())
  bank          QuestionBank         @relation(fields: [bankId], references: [id], onDelete: Cascade)
  options       QuestionBankOption[]

  @@map("question_bank_items")
}

model QuestionBankOption {
  id        String           @id @default(cuid())
  itemId    String
  content   String
  order     Int
  createdAt DateTime         @default(now())
  item      QuestionBankItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@map("question_bank_options")
}

model ExamAttempt {
  id          String            @id @default(cuid())
  examId      String
  studentId   String
  status      ExamAttemptStatus @default(IN_PROGRESS)
  score       Float?
  totalScore  Float?
  startedAt   DateTime          @default(now())
  submittedAt DateTime?
  expiresAt   DateTime
  answers     Answer[]
  exam        Exam              @relation(fields: [examId], references: [id], onDelete: Cascade)
  student     User              @relation(fields: [studentId], references: [id], onDelete: Cascade)
  payment     Payment?

  @@unique([examId, studentId])
  @@map("exam_attempts")
}

model Answer {
  id         String      @id @default(cuid())
  attemptId  String
  questionId String
  optionId   String?
  content    String?
  isCorrect  Boolean?
  points     Float?
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  attempt    ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  option     Option?     @relation(fields: [optionId], references: [id])
  question   Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([attemptId, questionId])
  @@map("answers")
}

model Payment {
  id              String        @id @default(cuid())
  studentId       String
  examId          String?
  attemptId       String?       @unique
  amount          Float
  status          PaymentStatus @default(PENDING)
  transactionId   String?       @unique
  stripePaymentId String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  adminAmount     Float?
  teacherAmount   Float?
  teacherId       String?
  attempt         ExamAttempt?  @relation(fields: [attemptId], references: [id])
  exam            Exam?         @relation(fields: [examId], references: [id], onDelete: Cascade)
  student         User          @relation(fields: [studentId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model Withdrawal {
  id          String           @id @default(cuid())
  userId      String
  amount      Float
  status      WithdrawalStatus @default(PENDING)
  reason      String?
  bankAccount String?
  bankName    String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  completedAt DateTime?
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("withdrawals")
}

enum UserRole {
  STUDENT
  TEACHER
  ADMIN
}

enum QuestionType {
  MULTIPLE_CHOICE
  OPEN_ENDED
  READING_COMPREHENSION
}

enum ExamStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ExamAttemptStatus {
  IN_PROGRESS
  COMPLETED
  TIMED_OUT
}

enum WithdrawalStatus {
  PENDING
  COMPLETED
  REJECTED
}
